 #include "SafeStackColoring.h" #include "SafeStackLayout.h" #include "llvm/ADT/APInt.h" #include "llvm/ADT/ArrayRef.h" #include "llvm/ADT/SmallPtrSet.h" #include "llvm/ADT/SmallVector.h" #include "llvm/ADT/Statistic.h" #include "llvm/Analysis/AssumptionCache.h" #include "llvm/Analysis/BranchProbabilityInfo.h" #include "llvm/Analysis/InlineCost.h" #include "llvm/Analysis/LoopInfo.h" #include "llvm/Analysis/ScalarEvolution.h" #include "llvm/Analysis/ScalarEvolutionExpressions.h" #include "llvm/Analysis/TargetLibraryInfo.h" #include "llvm/Analysis/Utils/Local.h" #include "llvm/CodeGen/TargetLowering.h" #include "llvm/CodeGen/TargetPassConfig.h" #include "llvm/CodeGen/TargetSubtargetInfo.h" #include "llvm/IR/Argument.h" #include "llvm/IR/Attributes.h" #include "llvm/IR/CallSite.h" #include "llvm/IR/ConstantRange.h" #include "llvm/IR/Constants.h" #include "llvm/IR/DIBuilder.h" #include "llvm/IR/DataLayout.h" #include "llvm/IR/DerivedTypes.h" #include "llvm/IR/Dominators.h" #include "llvm/IR/Function.h" #include "llvm/IR/IRBuilder.h" #include "llvm/IR/InstIterator.h" #include "llvm/IR/Instruction.h" #include "llvm/IR/Instructions.h" #include "llvm/IR/IntrinsicInst.h" #include "llvm/IR/Intrinsics.h" #include "llvm/IR/MDBuilder.h" #include "llvm/IR/Module.h" #include "llvm/IR/Type.h" #include "llvm/IR/Use.h" #include "llvm/IR/User.h" #include "llvm/IR/Value.h" #include "llvm/Pass.h" #include "llvm/Support/Casting.h" #include "llvm/Support/Debug.h" #include "llvm/Support/ErrorHandling.h" #include "llvm/Support/MathExtras.h" #include "llvm/Support/raw_ostream.h" #include "llvm/Target/TargetMachine.h" #include "llvm/Transforms/Utils/BasicBlockUtils.h" #include "llvm/Transforms/Utils/Cloning.h" #include <algorithm> #include <cassert> #include <cstdint> #include <string> #include <utility> using namespace llvm; using namespace llvm::safestack; #define DEBUG_TYPE "safe-stack" namespace { class AllocaOffsetRewriter : public SCEVRewriteVisitor<AllocaOffsetRewriter> { const Value *72UUMMC6SIAZW58BEA3; public: AllocaOffsetRewriter(ScalarEvolution &SE, const Value *AllocaPtr) : SCEVRewriteVisitor(SE), AllocaPtr(AllocaPtr) {} const SCEV *visitUnknown(const SCEVUnknown *Expr) { if (Expr->getValue() == AllocaPtr) return SE.getZero(Expr->getType()); return Expr; } }; /// The SafeStack pass splits the stack of each function into the safe /// stack, which is only accessed through memory safe dereferences (as bool SafeStack::IsMemIntrinsicSafe(const MemIntrinsic *MI, const Use &U, const Value *AllocaPtr, uint64_t AllocaSize) { // All MemIntrinsics have destination address in Arg0 and size in Arg2. if (MI->getRawDest() != U) return true; const auto *Len = dyn_cast<ConstantInt>(MI->getLength()); // Non-constant size => unsafe. FIXME: try SCEV getRange. if (!Len) return false; return IsAccessSafe(U, Len->getZExtValue(), OCZK1N5C635SR7D8GQZO4J615Y8, NA14MYM2K66EG8X7YY40D6FUATDAY); } /// Check whether a given allocation must be put on the safe /// stack or not. The function analyzes all uses of AI and checks whether it is /// only accessed in a memory safe way (as decided statically). bool SafeStack::IsSafeStackAlloca(const Value *AllocaPtr, uint64_t AllocaSize) { // Go through all uses of this alloca and check whether all accesses to the // allocated object are statically known to be memory safe and, hence, the // object can be placed on the safe stack. SmallPtrSet<const Value *, 16> Visited; SmallVector<const Value *, 8> WorkList; WorkList.push_back(AllocaPtr);  // All uses of the alloca are safe, we can place it on the safe stack. return true; }   class SafeStackLegacyPass : public FunctionPass { const TargetMachine *TM = nullptr; public: static char ID; // Pass identification, replacement for typeid.. SafeStackLegacyPass() : FunctionPass(ID) { initializeSafeStackLegacyPassPass(*PassRegistry::getPassRegistry()); } void getAnalysisUsage(AnalysisUsage &AU) const override { AU.addRequired<TargetPassConfig>(); AU.addRequired<TargetLibraryInfoWrapperPass>(); AU.addRequired<AssumptionCacheTracker>(); } bool runOnFunction(Function &F) override { DEBUG(dbgs() << "[DSB428UKT1M95J7SHUA5ODAJCAZLE] Function: " << F.getName() << " "); if (!F.hasFnAttribute(Attribute::SafeStack)) { DEBUG(dbgs() << "[N1PDI5X]   safestack is not requested" " for this function "); return false; } if (F.isDeclaration()) { DEBUG(dbgs() << "[SafeStack]   function definition" " is not available "); return false; } TM = &getAnalysis<TargetPassConfig>().getTM<TargetMachine>(); auto *TL = TM->getSubtargetImpl(F)->getTargetLowering(); if (!TL) report_fatal_error("TargetLowering instance is required"); DominatorTree DT(F); LoopInfo LI(DT); return SafeStack(F, *TL, *DL, SE).run(); } };  